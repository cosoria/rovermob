<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Rovermob : Rover mobile app framework">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Rover Mobile App Toolkit</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/michaellperry/rovermob">View on GitHub</a>

          <img class="logo" src="http://qedcode.com/images/rovermob.png" />
          <h1 id="project_title">Rover</h1>
          <h2 id="project_tagline">Mobile App Toolkit</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/michaellperry/rovermob/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/michaellperry/rovermob/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
<h3>Mobile apps that work offline as well as online</h3>

<p>Occasionally-connected mobile apps cache the data that a user needs. This makes the apps
more responsive because they don't have to wait for the server.
It also means that the user can get to their data even if they don't have a signal.
And when they make changes, the app caches their work and sends it to the
distributor.</p>

<p>Other toolkits try to sync up relational models between client and server. But
Rover Mobile is message-based. Application state is stored as a history of partially
ordered facts. Facts are exchanged via message. And messages can be sent and received
in any order. Conflicts are detected, and can be presented to the user for resolution.</p>

<h3>Install Via NuGet</h3>

<p>Create a Windows Universal App project.</p>

<code>Install-Package RoverMob</code>

<h3>Create a View Model Locator</h3>

<p>If you prefer another pattern (for example ViewModel First), you may use that instead once
you understand the Toolkit. However, for your first app with Rover, please use the View Model
Locator pattern.</p>

<p>Create a class called ViewModelLocator. Inherit from ViewModelLocatorBase (in Assisticant).</p>

<pre>
public class ViewModelLocator : ViewModelLocatorBase
{
}
</pre>

<p>I like to create one view model locator per target platform: one for Windows and one for Windows Phone. You may choose to do otherwise, and put the view model locator in the shared code project or a portable class library.</p>

<p>Add an instance of this class to your App.xaml resource dictionary with the key &quot;Locator&quot;.</p>

<pre>
&lt;Application
    x:Class="MyApp.App"
    xmlns:vm="using:MyApp.ViewModels"&gt;
    &lt;Application.Resources&gt;
        &lt;ResourceDictionary&gt;
            &lt;vm:ViewModelLocator x:Key="Locator" /&gt;
        &lt;/ResourceDictionary&gt;
    &lt;/Application.Resources&gt;
&lt;/Application&gt;
</pre>

<p>Create a view model. Notice that it does not have a base class.</p>

<pre>
public class MainViewModel
{
}
</pre>

<p>Add a property for the main view model.</p>

<pre>
public class ViewModelLocator : ViewModelLocatorBase
{
    public object Main
    {
        get { return ViewModel(() => new MainViewModel()); }
    }
}
</pre>

<p>Bind the DataContext of the MainPage to the Main property of the Locator resource.</p>

<pre>
&lt;Page
    x:Class="MyApp.MainPage" 
    DataContext="{Binding Main, Source={StaticResource Locator}}" &gt;
&lt;/Page&gt;
</pre>

<p>At this point, it's good to add a simple getter-only property to the main view model. Inside the getter, return a hard-coded value. Then data bind this to a control on the view. This will help you verify that you've completed all the steps properly.</p>

<h3>Create a Model</h3>

<p>Objects in your model implement the IMessageHandler interface. Create a root object with a default implementation.</p>

<pre>
public class MyRootObject : IMessageHandler
{
    private readonly Guid _id;

    public MyRootObject(Guid id)
    {
        _id = id;
    }

    public Guid GetObjectId()
    {
        return _id;
    }

    public IEnumerable&lt;IMessageHandler&gt; Children
    {
        get { return Enumerable.Empty&lt;IMessageHandler&gt;(); }
    }

    public void HandleMessage(Message message)
    {
    }

    public void HandleAllMessages(IEnumerable&lt;Message&gt; messages)
    {
    }
}
</pre>

<h3>Create an Application</h3>

<p>Create an Application&lt;TRoot&gt; in the view model locator. Load the application with
a root object.</p>

<pre>
public class ViewModelLocator : ViewModelLocatorBase
{
    private Application&lt;MyRootObject&gt; _application;
        
    public ViewModelLocator()
    {
        if (DesignMode)
            _application = LoadDesignModeApplication();
        else
            _application = LoadApplication();
    }

    public object Main
    {
        get { return ViewModel(() => new MainViewModel(_application)); }
    }

    private static Application&lt;MyRootObject&gt; LoadDesignModeApplication()
    {
        var application = new Application&lt;MyRootObject&gt;();
        application.Load(new MyRootObject(Guid.NewGuid()));
        return application;
    }
    
    private static Application&lt;MyRootObject&gt; LoadApplication()
    {
        string folderName = "MyApp";
        var store = new FileMessageStore(folderName);
        var queue = new FileMessageQueue(folderName);
        var bookmarkStore = new FileBookmarkStore(folderName);
        var pump = new HttpMessagePump(
            new Uri("http://host/api/distributor/", UriKind.Absolute),
            queue,
            bookmarkStore);
        var push = new PushNotificationSubscription();
        var application = new Application&lt;MyRootObject&gt;(
            store, queue, pump, push);
        application.Load(new MyRootObject(Guid.NewGuid()));
        return application;
    }
}
</pre>

<h3>Learn More on Pluralsight</h3>

<p>This library was extracted from the example application built in <a href="http://www.pluralsight.com/courses/occasionally-connected-windows-mobile-apps-collaboration">
Occasionally Connected Windows Mobile Apps: Collaboration</a>.
It is used as the foundation for other courses in that series.</p>

<h3>
<a id="authors-and-contributors" class="anchor" href="#authors-and-contributors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Authors and Contributors</h3>

<p>A product of <a href="https://github.com/michaellperry" class="user-mention">@michaellperry</a>.</p>

<h3>
<a id="support-or-contact" class="anchor" href="#support-or-contact" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support or Contact</h3>

<p>Comments or questions? Open an <a href="https://github.com/michaellperry/rovermob/issues">issue</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Rovermob maintained by <a href="https://github.com/michaellperry">michaellperry</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
